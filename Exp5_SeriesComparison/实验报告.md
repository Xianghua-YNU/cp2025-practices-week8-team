# 实验五：不同形式级数求和的数值稳定性比较实验报告

## 1. 实验目的
1. 实现并比较三种不同形式的调和级数求方法和
2. 观察和量化不同计算形式在数值精度上的差异
3. 理解灾难性抵消对数值计算的影响
4. 分析不同求和方法的误差增长趋势

## 2. 实验原理
### 2.1 三种级数形式
1. 交错级数形式：

$$ S_N^{(1)} = \sum_{n=1}^{2N} (-1)^n \frac{n}{n+1} $$

2. 两项求和相减形式：

$$ S_N^{(2)} = -\sum_{n=1}^{N} \frac{2n-1}{2n} + \sum_{n=1}^{N} \frac{2n}{2n+1} $$

3. 直接求和形式：

$$ S_N^{(3)} = \sum_{n=1}^{N} \frac{1}{2n(2n+1)} $$

### 2.2 相对误差计算
以 $S_N^{(3)}$ 为参考值，计算其他两种方法的相对误差：

$$ \text{Err}_1 = \left| \frac{S_N^{(1)} - S_N^{(3)}}{S_N^{(3)}} \right| $$
$$ \text{Err}_2 = \left| \frac{S_N^{(2)} - S_N^{(3)}}{S_N^{(3)}} \right| $$

## 3. 实验方法
### 3.1 代码实现
1. `sum_S1(N)` 函数实现：
       result = 0.0
    for n in range(1, 2*N + 1):
        result += (-1)**n * n / (n + 1)
    return result
   for循环求和

3. `sum_S2(N)` 函数实现：
    sum1 = sum2 = 0.0
    for n in range(1, N + 1):
        sum1 += (2*n - 1) / (2*n)
        sum2 += (2*n) / (2*n + 1)
    return -sum1 + sum2
   for循环，两项求和相减

5. `sum_S3(N)` 函数实现：
   result = 0.0
    for n in range(1, N + 1):
        result += 1.0 / (2*n * (2*n + 1))
    return result
for循环求和
   
### 3.2 数据收集与处理
1. N值选取：使用 `np.logspace(0, 4, 50)` 在对数尺度上取点
2. 计算三种方法的求和结果
3. 计算相对误差
4. 绘制双对数误差图

## 4. 实验结果
### 4.1 数据记录
| N | $S_N^{(1)}$ | $S_N^{(2)}$ | $S_N^{(3)}$ | $\text{Err}_1$ | $\text{Err}_2$ |
|---|-------------|-------------|-------------|----------------|----------------|
| 10 | 0.28360955 | 0.28360955 | 0.28360955 | 3.91e-16 | 4.70e-15 |
| 100 | 0.30437145 | 0.30437145 | 0.30437145 | 2.55e-15 | 1.51e-13 |
| 1000 | 0.30660301 | 0.30660301 | 0.30660301 | 1.16e-14 | 5.75e-12 |
| 10000 | 0.30682782 | 0.30682782 | 0.30682782 | 5.26e-14 | 5.62e-11 |

### 4.2 误差分析图
![Figure_1](https://github.com/user-attachments/assets/6a34cf0e-bc89-4082-8c50-4ef7cbcee141)


## 5. 分析与讨论
### 5.1 误差大小比较
1. 不同方法的误差比较：
   - （分析哪种方法误差更小）S2误差更小
   - （分析误差增长速度）S3误差增长更快

2. 灾难性抵消分析：
   - （分析 $S_N^{(2)}$中两个内部和的变化）其与标准值偏离越来越大，且明显大于S3的误差
   - （解释为什么会发生灾难性抵消）S2级数每一项都比别的级数多一步减法，这一步减法在两项大小相近时会由于舍入误差使得误差急剧增长

### 5.2 误差增长行为
1. 误差与N的幂律关系：
   - （分析双对数图的线性部分）error1与error2都在实验数据范围内呈现幂律关系，error1幂律关系良好，error2次之，存在不稳定振动
   - （估算幂指数p）error1幂指数大约在1左右，error2幂指数大约在2左右。

2. 误差增长原因：
   - （从数值计算角度解释误差增长的原因）
   - 每次计算都会将上一次计算的误差迭代进来，导致误差一步步积累，一步步上翻

## 6. 结论
1. 不同计算形式的数值稳定性比较         单项式误差小，多项式求和作差误差会显著增加。故而最好用单项式计算以减小误差
2. 灾难性抵消对计算精度的影响          显著增大数值计算误差，在计算次数多的时候会比其他误差大好几个数量级
3. 数学等价与数值计算的关系        数值计算在一定的精度范围内与数学相符，由于其有限精度计算，连续计算次数越多，误差越大，与数学偏离越大。数值计算如同数学实验，只能无限逼近真值而不达到。

## 7. 思考题
1. 为什么数学上等价的表达式在数值计算中会有如此大的差异？
   由于计算机表示小数的有限精度，误差会在一步步计算中逐步积累，最后可能会比真值还显著

3. 在实际编程中，如何避免类似的数值不稳定性？
   尽量避免多项式加减的连续计算，多用单项式计算。

5. 除了本实验中的三种形式，你能想到其他数值更稳定的计算方式吗？
   在某些情况下，可先将浮点数化为整数，计算后就可能避免舍入误差等

## 附录：关键代码
```python
# 在此粘贴关键代码实现
```
