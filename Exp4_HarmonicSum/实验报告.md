# 实验四：调和级数求和顺序与舍入误差实验报告

## 1. 实验目的
1. 实现并比较两种调和级数求和方法
2. 量化分析不同求和顺序导致的计算结果差异
3. 理解浮点数舍入误差的累积效应
4. 探究求和顺序对数值计算精度的影响

## 2. 实验原理
### 2.1 调和级数部分和
调和级数的前N项和定义为：

$$ S_N = \sum_{n=1}^{N} \frac{1}{n} $$

### 2.2 两种求和方法
1. 从小到大求和（ $S^{(up)}$）：

$$ S^{(up)} = \sum_{n=1}^{N}\frac{1}{n} = \frac{1}{1} + \frac{1}{2} + \frac{1}{3} + \cdots + \frac{1}{N} $$

2. 从大到小求和（ $S^{(down)}$）：

$$ S^{(down)} = \sum_{n=N}^{1}\frac{1}{n} = \frac{1}{N} + \frac{1}{N-1} + \cdots + \frac{1}{2} + \frac{1}{1} $$

### 2.3 相对差异计算
两种方法的相对差异定义为：

$$ \delta = \frac{|S^{(up)} - S^{(down)}|}{|(S^{(up)} + S^{(down)}) / 2|} $$

## 3. 实验方法
### 3.1 代码实现
- 实现 `sum_up(N)` 函数，从小到大计算调和级数和
- 实现 `sum_down(N)` 函数，从大到小计算调和级数和

### 3.2 数据收集
对不同的N值进行计算：
1. N值选取：使用 `np.logspace(1, 4, 50)` 在对数尺度上均匀取点
2. 计算并记录相对差异

## 4. 实验结果
### 4.1 数据记录

| N | $S^{(up)}$ | $S^{(down)}$ | 相对差异 δ |
|---|------------|--------------|------------|
|10	|2.928968253968|	2.928968253968	|0.00000000e+00|
|100	|5.187377517640|	5.187377517640	|1.71219160e-16|
|1000	|7.485470860550|	7.485470860550	|3.55960942e-16|
|10000|	9.787606036044|	9.787606036044|	3.81129905e-15|

### 4.2 误差分析图
（在此插入相对差异δ随N变化的双对数图）
![image](https://github.com/user-attachments/assets/8eab306e-e2b7-4985-be14-e9d759259ad9)

## 5. 分析与讨论
### 5.1 结果分析
1. 相对差异随N的变化趋势：
   - （分析图表趋势）
从实验数据和误差分析图（双对数图）可见，随着 N 的增大，相对差异 δ 呈现逐渐增长的趋势。在对数尺度下，δ 与 N 的关系近似为线性，表明误差随 N 的增大而以一定规律累积。具体而言：
当 N 较小时（如 N=10），两种求和顺序的结果完全一致（δ=0），这是因为较小的 N 对应的项数少，每一项的数值较大且累加过程中量级差异较小，浮点数舍入误差尚未显著累积。
随着 N 增大（如 N=100、1000、10000），δ 逐渐增大，且增长速率在双对数图中趋于稳定，反映出求和顺序对舍入误差的影响随项数增加而显著增强。
2. 舍入误差累积效应：
   - （分析为什么 $S^{(down)}$更精确）
   - 在浮点数加法中，当两个数的量级相近时，相加后的舍入误差较小；而从小到大求和时，初始项为 1，后续累加的 \(\frac{1}{n}\) 随 n 增大而迅速减小，导致后续的小数与当前累加和的量级差异逐渐扩大（例如，当累加和为 1000 时，加上 \(\frac{1}{1000}=0.001\)，此时小数的量级比和小 3 个数量级）。根据浮点数的尾数精度限制，较小的数在与较大的数相加时，其有效数字可能被截断，导致 “大数吃小数” 现象，舍入误差逐次累积。
   - （结合浮点数表示方式解释）
浮点数（如 IEEE 754 双精度）的尾数通常有 52 位有效数字，当两个数的绝对值相差超过 \(2^{52}\) 倍时，较小数的尾数在加法中会被完全忽略。从小到大求和时，随着累加和增大，后续的 \(\frac{1}{n}\) 相对于当前和的量级不断缩小，最终可能低于浮点数的精度阈值，导致有效信息丢失。
### 5.2 误差来源分析
1. 浮点数表示精度限制
2. 加法运算中的舍入
3. 求和顺序的影响

## 6. 结论
（总结实验发现，特别是关于求和顺序对计算精度的影响）
本实验通过调和级数的两种求和顺序，验证了数值计算中舍入误差的累积效应及求和顺序对精度的显著影响
求和顺序误差随 N 增大而累积影响精度

## 7. 思考题
1. 为什么从大到小求和通常能获得更好的精度？
从大到小求和时，每次相加的两个数量级相近，减少了浮点数加法中因量级差异过大导致的有效数字丢失（即 “大数吃小数” 现象）。例如，先加较大的数（如 1），再逐步加入较小的数（如 \(\frac{1}{2}, \frac{1}{3}\)），此时每次相加的数与当前和的量级差异较小，尾数部分能更完整地参与运算，舍入误差更小。
2. 在实际应用中，如何选择合适的求和策略来减小舍入误差？
 优先按绝对值从大到小的顺序求和：尤其当数列包含正负相间或量级差异较大的项时，此策略可减少 “大数吃小数” 的误差。分组求和：将量级相近的项先分组，再对各组结果求和，避免跨量级的直接相加。使用高精度数据类型：如 Python 中的decimal模块或双精度浮点数（比单精度更优），扩大尾数有效位数。误差补偿算法：如 Kahan 求和算法，通过额外变量累积误差，提高求和精度。
3. 除了改变求和顺序，还有什么方法可以提高数值计算的精度？
 使用更高精度的数值表示：如任意精度算术库（如 Python 的decimal模块）或扩展精度浮点数（如 Quadruple-precision）。误差补偿技术：如 Kahan 求和算法、Neumaier 求和算法，通过显式跟踪舍入误差并进行补偿。数学变换：将求和式转换为更稳定的形式，例如利用级数的收敛性质或近似公式（如调和级数的欧拉 - 马歇罗尼常数近似）减少计算步数。
## 附录：关键代码
```python
# 在此粘贴关键代码实现
```def sum_up(N):
    """从小到大计算调和级数和：H_N = 1 + 1/2 + ... + 1/N"""
    result = 0.0
    for n in range(1, N + 1):
        result += 1.0 / n
    return result

def sum_down(N):
    """从大到小计算调和级数和：H_N = 1/N + ... + 1/2 + 1"""
    result = 0.0
    for n in range(N, 0, -1):
        result += 1.0 / n
    return result

def calculate_relative_difference(N):
    """计算两种方法的相对差异"""
    s_up = sum_up(N)
    s_down = sum_down(N)
    return abs(s_up - s_down) / abs((s_up + s_down) / 2.0) if (s_up + s_down) != 0 else 0.0

def plot_differences():
    """绘制相对差异随N的变化"""
    N_values = np.logspace(1, 4, 50, dtype=int)
    differences = [calculate_relative_difference(N) for N in N_values]
    
    plt.figure(figsize=(10, 6))
    plt.loglog(N_values, differences, 'o-', alpha=0.7)
    
    plt.grid(True, which="both", ls="-", alpha=0.2)
    plt.xlabel('N')
    plt.ylabel('Relative Difference')
    plt.title('Relative Difference vs N')
    
    plt.savefig('harmonic_sum_differences.png', dpi=300, bbox_inches='tight')
    plt.show()

def print_results():
    """打印典型N值的计算结果"""
    N_values = [10, 100, 1000, 10000]
    
    print("\n计算结果:")
    print("N\tS_up\t\t\tS_down\t\t\t相对差异")
    print("-" * 80)
    
    for N in N_values:
        s_up = sum_up(N)
        s_down = sum_down(N)
        diff = calculate_relative_difference(N)
        print(f"{N}\t{s_up:.12f}\t{s_down:.12f}\t{diff:.8e}")

