# 实验二：数值微分的误差权衡

## 1. 实验目的
- 理解数值微分中截断误差与舍入误差的权衡关系
- 观察有限差分法计算导数时的误差变化规律
- 分析步长对数值微分精度的影响
- 确定最优步长范围

## 2. 实验方法
### 2.1 理论基础
数值微分是通过有限差分近似导数的计算方法。本实验实现了两种差分方法：
- 前向差分法: $f'(x) \approx \frac{f(x+\delta) - f(x)}{\delta}$
- 中心差分法: $f'(x) \approx \frac{f(x+\delta) - f(x-\delta)}{2\delta}$

### 2.2 测试函数
本实验使用函数 $f(x) = x(x-1)$，其解析导数为 $f'(x) = 2x - 1$。

### 2.3 实验步骤
1. 实现前向差分和中心差分函数
2. 在 $x=1$ 点计算不同步长下的数值导数
3. 计算数值导数与解析导数的相对误差
4. 绘制误差-步长关系图（对数坐标）
5. 分析最优步长和收敛阶数

## 3. 实验结果
### 3.1 数据表格
| 步长(δ) | 前向差分值 | 中心差分值 | 解析解 | 前向差分相对误差 | 中心差分相对误差 |
|---------|------------|------------|--------|------------------|------------------|
| 1.00e-02 |1.000000e-02  |1.000000e-02 | 1.0    |1.000000e-02      |8.881784e-16      |
| 1.00e-04 |1.000000e-04  |1.000000e-04 | 1.0    |1.000000e-04      |1.101341e-13      |
| 1.00e-06 |9.999770e-07  |9.999770e-07 | 1.0    |9.999177e-07      |2.675549e-11      |
| 1.00e-08 |3.922529e-09  |3.922529e-09 | 1.0    |3.922529e-09      |5.263561e-10      |
| 1.00e-10 |8.284037e-08  |8.284037e-08 | 1.0    |8.284037e-08      |8.274037e-08      |
| 1.00e-12 |8.890058e-05  |8.890058e-05 | 1.0    |8.890058e-05      |3.338943e-05      |
| 1.00e-14 |7.992778e-04  |7.992778e-04 | 1.0    |7.992778e-04      |7.992778e-04      |

### 3.2 误差-步长关系图
（在此插入误差-步长关系图，并简要说明图中观察到的现象）
![image](https://github.com/user-attachments/assets/727ad268-4184-4c85-927b-c9d153d1f8ac)

## 4. 分析与讨论
### 4.1 误差来源分析
数值微分中存在两种主要误差来源：
- **截断误差**：由于使用有限差分近似导数定义引入的误差，通常随步长减小而减小
- **舍入误差**：由于计算机浮点数表示的有限精度引入的误差，通常随步长减小而增大

（分析实验中观察到的截断误差和舍入误差的表现）
数值微分实验清晰地展示了两种误差的竞争关系：
截断误差主导区：误差随步长减小呈幂律下降，收敛阶数符合理论预期。舍入误差理论上由差分除式的泰勒展开高阶项决定，故在表现形式上体现为平行于一二阶辅助线。
舍入误差主导区：误差因浮点精度限制反弹上升，与步长成反比。
最优步长：通过平衡两种误差，中心差分因高阶精度允许更小的最优步长，显著提升计算精度。
这一分析为选择合适步长提供了依据：使用中心差分方法并选择接近最优步长的 δ，可最大限度降低总误差。
### 4.2 前向差分与中心差分的比较
（比较两种方法的精度差异，并解释原因）
在数值微分中，中心差分法相较于前向差分法展现出显著的精度优势。
截断误差主导区（较大步长）：
前向差分：误差随 δ线性下降（斜率1）
中心差分：误差随 δ**2 下降（斜率2），收敛更快，导致最优步长小
舍入误差主导区（过小步长）：
两者误差均反弹，但中心差分因最优步长更小，反弹起始点更晚
### 4.3 最优步长分析
（分析实验中观察到的最优步长，并解释为什么存在最优步长）
中心差分为10**（-6），向前差分为10**（-8），
存在原因：总误差 = 截断误差 + 舍入误差，总误差最小时，两误差互相抵抗，达到误差极小值
### 4.4 收敛阶数分析
（分析两种方法的收敛阶数，并与理论预期进行比较）
实验结果与理论预期合，验证了数值微分方法的收敛性能。前向差分法以一阶速度收敛，中心差分法以二阶速度收敛，后者因高阶精度和更优的误差平衡，在实际应用中显著优于前者。通过合理选择步长，可最大限度发挥算法优势，避免舍入误差的负面影响。舍入误差理论上由被差分函数f的在x的泰勒展开高阶项决定，故在表现形式上体现为平行于一二阶辅助线
前向差分法中间区域实验斜率接近1，与一阶理论一致。
中心差分法中间区域实验斜率接近2，验证二阶收敛。
## 5. 实验结论
（总结本实验的主要发现，特别是关于误差权衡、最优步长和不同差分方法的优缺点）
实验结果与理论预期合，验证了数值微分方法的收敛性能。前向差分法以一阶速度收敛，中心差分法以二阶速度收敛，后者因高阶精度和更优的误差平衡，在实际应用中显著优于前者。通过合理选择步长，可最大限度发挥算法优势，避免舍入误差的负面影响。在数值微分中，中心差分法相较于前向差分法展现出显著的精度优势。
## 附录：核心代码片段
```python
# 前向差分法实现
def forward_diff(f, x, delta):
    return (f(x + delta) - f(x)) / delta

# 中心差分法实现
def central_diff(f, x, delta):
    return (f(x + delta) - f(x - delta)) / (2 * delta)

# 计算误差的代码
# TrueValue = analytical_derivative(x_point)
    
    deltas = np.logspace(-14,-2,13)
    #解析解
    analytical_derivative(x_point)
    #存储列表
    forwarderrors = []
    centralerrors = []
    
    for delta in deltas:
        forward_error = abs((forward_diff(f, x_point, delta) - TrueValue)/TrueValue)
        forwarderrors.append(forward_error)
        
        central_error = abs((central_diff(f, x_point, delta) - TrueValue)/TrueValue)
        centralerrors.append(central_error)
        
    return deltas,forwarderrors,centralerrors

# 绘制误差-步长关系图的代码
# plt.figure(figsize = (10,8))
    #向前差分误差
    plt.loglog(deltas, forward_errors, 'o-', label='forward')
    plt.loglog(deltas, central_errors, 's-', label='central')
    #参考线
    plt.loglog(deltas, deltas, '--', label='First Order O(h)')
    plt.loglog(deltas, np.array(deltas)**2, '--', label='Second Order O($h^2$)')
    
    plt.xlabel('Step')
    plt.xlabel('Error')
    plt.grid(True)
    plt.title('error_vs_stepsize')
    plt.legend()
    plt.show()
```
